name: Shared E2E Tests

# Make this workflow reusable
on:
  workflow_call:
    inputs:
      client_repo:
        description: 'The source repository for the yellow-client code'
        required: false
        type: string
        default: ''
      client_ref:
        description: 'The ref (branch, tag, commit) to checkout for the client code'
        required: false
        type: string
        default: ''

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Print working directory
      run: |
        pwd
        ls -la

    # Conditionally checkout the client repo if specified
    - name: Checkout custom client code
      if: inputs.client_repo != ''
      uses: actions/checkout@v3
      with:
        repository: ${{ inputs.client_repo }}
        ref: ${{ inputs.client_ref }}
        path: source-client
    
    - name: Checkout yellow-dev
      uses: actions/checkout@v3
      with:
        repository: koo5/yellow-dev
        ref: master
        path: yellow-dev
        submodules: recursive
    
    # Replace yellow-client code if a custom client was checked out
    - name: Replace yellow-client code with custom source
      if: inputs.client_repo != ''
      run: |
        rm -rf yellow-dev/yellow-client
        cp -r source-client yellow-dev/yellow-client
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install Python dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests
    
    - name: Set up Bun
      uses: oven-sh/setup-bun@v1
      with:
        bun-version: latest
    
    # Set up Docker buildx with layer caching capabilities
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
      id: buildx
      with:
        install: true
        driver-opts: |
          image=moby/buildkit:latest
          network=host
    
    # Cache Docker layers using GitHub's cache
    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-
    
    - name: Print directory structure
      run: |
        find . -type d -maxdepth 3
    
    - name: Install playwright
      run: |
        cd yellow-dev/yellow-client
        bun install
        bun x playwright install --with-deps
    
    - name: Install Fish Shell and MariaDB Client
      run: |
        sudo apt-get update
        sudo apt-get install -y fish mariadb-client
    
    # Set docker-compose to use buildx and cached layers
    - name: Run E2E Tests with layer caching
      run: |
        ls -la
        cd yellow-dev
        ls -la
        
        # Verify script exists
        if [ ! -f "scripts/run_compose_and_test.py" ]; then
          echo "ERROR: Test script not found at expected location scripts/run_compose_and_test.py"
          find . -name "run_compose_and_test.py"
          exit 1
        fi
        
        # Get UID and GID (same as in run_compose_and_test.py)
        UID=$(id -u)
        GID=$(id -g)
        
        # Create .env file for docker-compose
        echo "COMPOSE_DOCKER_CLI_BUILD=1" > .env
        echo "DOCKER_BUILDKIT=1" >> .env
        echo "BUILDKIT_PROGRESS=plain" >> .env
        echo "UID=$UID" >> .env
        echo "GID=$GID" >> .env
        echo "CI=true" >> .env
        
        # Add cache export configuration to docker-compose build commands
        # This is a workaround since docker-compose doesn't directly support BuildKit cache config
        # We'll intercept the regular docker-compose up command in the Python script
        
        # First, let's build the images with layer caching
        for service in $(docker-compose config --services); do
          echo "Building service $service with cached layers"
          
          # Get the image name from docker-compose
          image_name=$(docker-compose config | grep "image:" | grep -v "image: *\${" | awk '{print $2}' | grep -v "^$" | sort -u | head -1 || echo "")
          
          # If no image name found, use service name
          if [ -z "$image_name" ]; then
            image_name="yellow-dev-$service"
          fi
          
          # Get the build context
          context=$(docker-compose config | grep -A10 "services:" | grep -A10 "$service:" | grep "context:" | awk '{print $2}' || echo ".")
          
          # Build with cached layers
          docker buildx build \
            --builder=${{ steps.buildx.outputs.name }} \
            --tag $image_name \
            --build-arg UID=$UID \
            --build-arg GID=$GID \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max \
            --load \
            $context || echo "Failed to build $service with cache, will let docker-compose build it"
        done
        
        # Move the new cache
        rm -rf /tmp/.buildx-cache
        mv /tmp/.buildx-cache-new /tmp/.buildx-cache || true
        
        # Now run the tests (docker-compose will skip building images that were already built)
        python scripts/run_compose_and_test.py